# Мотивация

## Декомпозиция

В наши дни компоненты становятся такими большими и вариативными. Обычно вариативность выражается через большое количество произвольных условий внутри кода в императивном стиле. Работать с таким кодом сложно:
- тяжело оценить всю возможную вариативность
- логика определенной функциональности может быть размазана по нескольким местам в коде, что усложняет расширение и изменение компонентов

Кроме того, среднестатистический метод `render` несет в себе основную часть логики компонента. Переносить/переопределять/доопределять такой код сложно, по причине того, что приходиться переписывать добрую часть метода.

Описание всего возможного поведения внутри одного компонента, в случае опциональной вариативности, неизбежно приведёт к загрузке лишнего кода в рантайм. Не существуют удобного пути "рассказать" системе сборки какие именно части кода надо подключать в конкретном случае.

## Повторное использование кода

Компонентов становится много и они становятся достаточно сложными. Между ними появляется общий код. Хочется легко реиспользовать общие части. Сейчас есть два способа: классическое наследование и High Order Components.

С наследованием тяжело комбинировать несколько ортогональных признаков без полного перепроектирования иерархии классов. И вообще обладает целым рядом других проблем, о которых уже [не раз писали](https://en.wikipedia.org/wiki/Composition_over_inheritance).

В случае Hight Order Components, при композиции нескольких разных компонентов, отвечающих за разные аспекты функциональности, получается раздутие виртуального дерева и часто не обойтись без использования `React.cloneElement`.

## Кроссплатформенная разработка

Современные веб-сервисы вынуждены разрабатываться как минимум для десктопов и мобильных. Есть два подхода:
- две (и более) отдельных версии сервиса для разных платформ
- одна адаптивная версия

Каждый из них обладает своими недостатками.

Несколько отдельных версий требуют больше усилий (пропорционально количеству версий) и обостряют проблемы со сложностью повторно использовать код. И даже если у вас достаточно ресурсов, чтобы иметь разные версии, дополнительная сложностью будет поддержание их в синхронном состоянии с точки зрения продуктовых свойств.

Разрабатывая одну адаптивную версию прийдётся учитывать, что один и тот же код будет исполняться на разных платформах. Это всё усложняет! Сложность кода и требования к квалификации разработчиков становятся выше. Часто такой код имеет ещё и проблемы с производительностью, особенно на мобильных устройствах.

## Эксперименты

Чтобы успешно разрабатывать сервисы с большой аудиторией нужно быть уверенным в каждом изменении. A/B эксперименты, это один из способов получить такую уверенность.

Можно выделить два паттерна организации кода для проведения экспериментов:
- ветвление всей кодовой базы и создание отдельных экземпляров сервиса
- точечные условия внутри одной кодовой базы

Ветвление всей кодовой базы может вызвать существенные накладные расходы в случае большого количества долгоиграющих экспериментов, т.к. неизбежно придётся  синхронизировать изменения, например, багфиксы, продуктовую функциональность не требующую экспериментов и/или успешно их прошедшую. Кроме этого, становится сложно проводить пересекающиеся эксперименты.

С другой стороны, точечные условия внутри одной кодовой базы работают гибче, но ведут к усложнению кодовой базы. Большое количество условий затрудняет не только понимание кода для человека, но и ухудшает производительность (за счёт увеличения объёма кода для браузера). Кроме того, когда эксперимент завершился, то нужно избавиться от лишнего кода: убрать условия и сделать код основным или полностью удалить неудачный эксперимент. Т.к. код про один эксперимент может быть размазан по многим местам, а основная функциональность постоянно меняется, то это может быть не просто!

## Взаимодействие общей библиотеки компонентов и разных сервисов

При использовании общей библиотеки возникает ситуация, что ваш проект использует код сторонних авторов и своим релизным циклом. 

Иногда возникает необходимость сделать изменения в компонентах из библиотеки (на уровне своего проекта) до того как выйдет её следующий релиз. Например: багфиксы, изменения API, улучшения и оптимизация кода, дополнительная функциональность. 

А ещё такие изменения могут никогда не попасть в общую библиотеку, потому что они специфичны только для вашего проекта.

Существующие практики решения подобных проблем сводятся к вариантам:
- форк библиотеки
- патчинг библиотечного кода в рантайме
- наследование

В случае с форком вам нужно следить за обновлениями в апстриме и накладывать ваши патчи, что может быть не так просто. 

Патчинг библиотечного кода в рантайме обладает рядом проблем. Некоторые вещи может быть невозможно пропатчить, так как они скрыты в деталях библиотеки и не задумывались авторами библиотеки как изменяемые снаружи. Так же подобная практика существенно усложняет обновление библиотеки на новые версии, потому что авторы не учитывают ваши патчи при выпуске новых версий.

Наследованием может работать если вам нужно получить в своем коде измененный компонент из библиотеки. Например, вы можете сделать `MyButton` унаследованный от `Button`. Но в библиотеке может быть компонент `Search`, построенный композицей из `Input` и `Button`. В этом случае, используя компонент `Search` вы не получите внутри него унаследованный `MyButton`. 

В целом возможность делать всё это может быть заранее предусмотрено автором библиотеки, но к сожалению, это бывает далеко не всегда.
